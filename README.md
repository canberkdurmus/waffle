# Waffle

Waffle is a new programming language with a language description and its own compiler. Created only for academic
purposes. 

## Compiling Process Flow
- File should be read as array of lines  
- Lexical Analyzer cleans the comment lines, empty lines etc before starting the analysis (Preprocessor)  
- Every line that lexical analyzer read from the program file is tokenized as a LexLine  
- LexLines are appended as one dimensional array with $ symbols between the lines 
(This make us able to parse one line statements (assgnstat, returnstat etc) a lot easier in parsing phase)  
- Tokens from the lexical analyzer passed to the Parse Tree class initializer  
- Parser use the "get_next_token" to read the next token that that generated by Lexical Analyzer  
- Parser in the parse tree class executes a top-down recursive descent parsing operation  
- Parse Tree class also keeps the Symbol Table track while building the parse tree  
- Some parser checks (flow control) are completed while parse tree is being built 
(Because building a non balanced tree is actually traversing an unknown tree)  
- Some parser checks are being executed after the parse tree built (uniqueness, name-related)  
- Any error in the lexical analysis or parsing won't stop the compiling process, only error messages will be printed  


## Execution  
```
cd src
python3 main.py
```

## Output
### Lexical Analysis Output (Tokenization)
```
== Starting of lexical analysis == 

int a.............................................[('keyword', 'int'), ('id', 'a')]
int b.............................................[('keyword', 'int'), ('id', 'b')]
int c.............................................[('keyword', 'int'), ('id', 'c')]
int d.............................................[('keyword', 'int'), ('id', 'd')]
int result........................................[('keyword', 'int'), ('id', 'result')]
fun double (int first){...........................[('keyword', 'fun'), ('id', 'double'), ('symbol', '('), ('keyword', 'int'), ('id', 'first'), ('symbol', ')'), ('symbol', '{')]
    result = first * 2............................[('id', 'result'), ('assign_op', '='), ('id', 'first'), ('unary_op', '*'), ('int_num', '2')]
    return result.................................[('keyword', 'return'), ('id', 'result')]
}.................................................[('symbol', '}')]
fun sum (int first, int second){..................[('keyword', 'fun'), ('id', 'sum'), ('symbol', '('), ('keyword', 'int'), ('id', 'first'), ('symbol', ','), ('keyword', 'int'), ('id', 'second'), ('symbol', ')'), ('symbol', '{')]
    result = first + second.......................[('id', 'result'), ('assign_op', '='), ('id', 'first'), ('unary_op', '+'), ('id', 'second')]
    return result.................................[('keyword', 'return'), ('id', 'result')]
}.................................................[('symbol', '}')]
fun count (int target){...........................[('keyword', 'fun'), ('id', 'count'), ('symbol', '('), ('keyword', 'int'), ('id', 'target'), ('symbol', ')'), ('symbol', '{')]
    int from......................................[('keyword', 'int'), ('id', 'from')]
    from = 0......................................[('id', 'from'), ('assign_op', '='), ('int_num', '0')]
    if (from < target){...........................[('keyword', 'if'), ('symbol', '('), ('id', 'from'), ('bool_op', '<'), ('id', 'target'), ('symbol', ')'), ('symbol', '{')]
        loop (from < target) {....................[('keyword', 'loop'), ('symbol', '('), ('id', 'from'), ('bool_op', '<'), ('id', 'target'), ('symbol', ')'), ('symbol', '{')]
            from = from + 1.......................[('id', 'from'), ('assign_op', '='), ('id', 'from'), ('unary_op', '+'), ('int_num', '1')]
            if (from == 100){.....................[('keyword', 'if'), ('symbol', '('), ('id', 'from'), ('bool_op', '=='), ('int_num', '100'), ('symbol', ')'), ('symbol', '{')]
                break.............................[('keyword', 'break')]
            }.....................................[('symbol', '}')]
        }.........................................[('symbol', '}')]
    } else {......................................[('symbol', '}'), ('keyword', 'else'), ('symbol', '{')]
        return 0..................................[('keyword', 'return'), ('int_num', '0')]
    }.............................................[('symbol', '}')]
}.................................................[('symbol', '}')]
a = 10............................................[('id', 'a'), ('assign_op', '='), ('int_num', '10')]
b = 5.............................................[('id', 'b'), ('assign_op', '='), ('int_num', '5')]
c = a * 4.5 + b...................................[('id', 'c'), ('assign_op', '='), ('id', 'a'), ('unary_op', '*'), ('real_num', '4.5'), ('unary_op', '+'), ('id', 'b')]
d = double(c).....................................[('id', 'd'), ('assign_op', '='), ('id', 'double'), ('symbol', '('), ('id', 'c'), ('symbol', ')')]
loop ( d < 100) {.................................[('keyword', 'loop'), ('symbol', '('), ('id', 'd'), ('bool_op', '<'), ('int_num', '100'), ('symbol', ')'), ('symbol', '{')]
    d = d + 1.....................................[('id', 'd'), ('assign_op', '='), ('id', 'd'), ('unary_op', '+'), ('int_num', '1')]
}.................................................[('symbol', '}')]
if (a < 10) {.....................................[('keyword', 'if'), ('symbol', '('), ('id', 'a'), ('bool_op', '<'), ('int_num', '10'), ('symbol', ')'), ('symbol', '{')]
    a = a + 1.....................................[('id', 'a'), ('assign_op', '='), ('id', 'a'), ('unary_op', '+'), ('int_num', '1')]
} else {..........................................[('symbol', '}'), ('keyword', 'else'), ('symbol', '{')]
    a = a - 1.....................................[('id', 'a'), ('assign_op', '='), ('id', 'a'), ('unary_op', '-'), ('int_num', '1')]
}.................................................[('symbol', '}')]

== End of lexical analysis == 
```

### Parser Output
```
== Begin Parse Tree Traverse ==
decl
|---- ['int', 'a']
decl
|---- ['int', 'b']
decl
|---- ['int', 'c']
decl
|---- ['int', 'd']
decl
|---- ['int', 'result']
functiondecl
|---- fun
|---- double
|---- (
|----decls
|----|---- int
|----|---- first
|---- )
|---- {
|----compoundtat
|----|----assgstat
|----|----|---- result
|----|----|---- =
|----|----|---- first
|----|----|---- *
|----|----|---- 2
|----|----returnstat
|----|----|---- return
|----|----|---- result
|---- }
functiondecl
|---- fun
|---- sum
|---- (
|----decls
|----|---- int
|----|---- first
|----|---- ,
|----|---- int
|----|---- second
|---- )
|---- {
|----compoundtat
|----|----assgstat
|----|----|---- result
|----|----|---- =
|----|----|---- first
|----|----|---- +
|----|----|---- second
|----|----returnstat
|----|----|---- return
|----|----|---- result
|---- }
functiondecl
|---- fun
|---- count
|---- (
|----decls
|----|---- int
|----|---- target
|---- )
|---- {
|----compoundtat
|----|----decl
|----|----|---- ['int', 'from']
|----|----assgstat
|----|----|---- from
|----|----|---- =
|----|----|---- 0
|----|----ifstat
|----|----|---- if
|----|----|---- (
|----|----|----boolexp
|----|----|----|---- ('id', 'from')
|----|----|----|---- ('bool_op', '<')
|----|----|----|---- ('id', 'target')
|----|----|---- )
|----|----|---- {
|----|----|----compoundstat
|----|----|----|----loopstat
|----|----|----|----|---- loop
|----|----|----|----|---- (
|----|----|----|----|----boolexp
|----|----|----|----|----|---- ('id', 'from')
|----|----|----|----|----|---- ('bool_op', '<')
|----|----|----|----|----|---- ('id', 'target')
|----|----|----|----|---- )
|----|----|----|----|---- {
|----|----|----|----|----compundstat
|----|----|----|----|----|----assgstat
|----|----|----|----|----|----|---- from
|----|----|----|----|----|----|---- =
|----|----|----|----|----|----|---- from
|----|----|----|----|----|----|---- +
|----|----|----|----|----|----|---- 1
|----|----|----|----|----|----ifstat
|----|----|----|----|----|----|---- if
|----|----|----|----|----|----|---- (
|----|----|----|----|----|----|----boolexp
|----|----|----|----|----|----|----|---- ('id', 'from')
|----|----|----|----|----|----|----|---- ('bool_op', '==')
|----|----|----|----|----|----|----|---- ('int_num', '100')
|----|----|----|----|----|----|---- )
|----|----|----|----|----|----|---- {
|----|----|----|----|----|----|----compoundstat
|----|----|----|----|----|----|----|----breakstat
|----|----|----|----|----|----|----|----|---- break
|----|----|----|----|----|----|---- }
|----|----|----|----|---- }
|----|----|---- }
|----|----|---- else
|----|----|---- {
|----|----|----compoundstat
|----|----|----|----returnstat
|----|----|----|----|---- return
|----|----|----|----|---- 0
|----|----|---- }
|---- }
assgstat
|---- a
|---- =
|---- 10
assgstat
|---- b
|---- =
|---- 5
assgstat
|---- c
|---- =
|---- a
|---- *
|---- 4.5
|---- +
|---- b
assgstat
|---- d
|---- =
|---- double
|---- (
|---- c
|---- )
loopstat
|---- loop
|---- (
|----boolexp
|----|---- ('id', 'd')
|----|---- ('bool_op', '<')
|----|---- ('int_num', '100')
|---- )
|---- {
|----compundstat
|----|----assgstat
|----|----|---- d
|----|----|---- =
|----|----|---- d
|----|----|---- +
|----|----|---- 1
|---- }
ifstat
|---- if
|---- (
|----boolexp
|----|---- ('id', 'a')
|----|---- ('bool_op', '<')
|----|---- ('int_num', '10')
|---- )
|---- {
|----compoundstat
|----|----assgstat
|----|----|---- a
|----|----|---- =
|----|----|---- a
|----|----|---- +
|----|----|---- 1
|---- }
|---- else
|---- {
|----compoundstat
|----|----assgstat
|----|----|---- a
|----|----|---- =
|----|----|---- a
|----|----|---- -
|----|----|---- 1
|---- }
== End Parse Tree Traverse ==

```
### Symbol Table Output
```
- Symbol Table -
|-------|-------|
| a 	| int 	|
|-------|-------|
| b 	| int 	|
|-------|-------|
| c 	| int 	|
|-------|-------|
| d 	| int 	|
|-------|-------|
| result| int 	|
|-------|-------|
| from 	| int 	|
|-------|-------|
```

## Grammar

decls → decl, decls | Ɛ  
decl → int ID | str ID | real ID  
functiondecl → fun ID ( decls ) compoundstat  
stat → ifstat | loopstat | assgstat | compoundstat | returnstat | breakstat  
compoundstat → { stats }  
stats → stat stats | Ɛ  
ifstat → if ( boolexpr ) compundstat else compundstat | if ( boolexp ) compundstat  
loopstat → loop ( boolexpr ) compundstat  
assgnstat → ID assgnop arithexpr  
assgnop → =   
returnstat → return arithexp  
breakstat → break  
boolexp → aritexp boolop aritexp  
boolop → < | > | <= | >= | == | !=  
unaryexp → unaryop aritexp  
unaryop → + | -  
aritexp → aritexpr + multexp | aritexp - multexp | multexps  
multexp → multexpr*simpleexpr | multexp/simplexp | simplexp  
simplexp → ID | INTNUM | REALNUM | STRING | ( aritexp )

## Lexical Structure

**Comments:** Comments start with the # character and end with the end of line character.  
**Keywords:** int, str, real, fun, if, else, loop, and, or  
**Identifiers:** An identifier includes only lower case letters or underscores. A keyword cannot be an identifier.  
**Operators:** < | > | <= | >= | == | != | < | > | <= | >= | == | !=  
**Delimiters:** whitespace, tab, newline  
**Numbers:**
digit → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9  
intnumber → digit+  
fraction → .digit+  
realnumber → digit+ fraction ( exponent | Ɛ)
